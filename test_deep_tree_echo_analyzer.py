#!/usr/bin/env python3
"""
Test script for Deep Tree Echo Analyzer module

Tests the analysis tool functionality for identifying architecture gaps,
fragments, and migration tasks.
"""

import unittest
import logging
import sys
import tempfile
import json
from unittest.mock import Mock, patch, mock_open
from pathlib import Path
from datetime import datetime

# Add the current directory to the path for imports
sys.path.insert(0, str(Path(__file__).parent))

# Import the module under test
try:
    from deep_tree_echo_analyzer import DeepTreeEchoAnalyzer
    ANALYZER_AVAILABLE = True
except ImportError as e:
    ANALYZER_AVAILABLE = False
    print(f"Warning: Could not import deep_tree_echo_analyzer: {e}")


class TestDeepTreeEchoAnalyzer(unittest.TestCase):
    """Test cases for deep_tree_echo_analyzer module"""

    def setUp(self):
        """Set up test fixtures"""
        # Suppress logging output during tests
        logging.getLogger().setLevel(logging.CRITICAL)

    def test_import_deep_tree_echo_analyzer(self):
        """Test that deep_tree_echo_analyzer module can be imported"""
        if not ANALYZER_AVAILABLE:
            self.skipTest("deep_tree_echo_analyzer module not available")
        
        self.assertTrue(ANALYZER_AVAILABLE)

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_analyzer_creation(self):
        """Test DeepTreeEchoAnalyzer class instantiation"""
        with tempfile.TemporaryDirectory() as temp_dir:
            analyzer = DeepTreeEchoAnalyzer(temp_dir)
            
            self.assertEqual(analyzer.repo_path, Path(temp_dir))
            self.assertIsInstance(analyzer.results, dict)
            
            # Check expected result structure
            expected_keys = ['fragments', 'architecture_gaps', 'migration_tasks', 
                           'analysis_timestamp', 'recommendations']
            for key in expected_keys:
                self.assertIn(key, analyzer.results)

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_default_repo_path(self):
        """Test default repository path handling"""
        analyzer = DeepTreeEchoAnalyzer()
        self.assertEqual(analyzer.repo_path, Path("."))

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_results_structure(self):
        """Test that results dictionary has correct structure"""
        analyzer = DeepTreeEchoAnalyzer()
        
        # Test initial structure
        self.assertIsInstance(analyzer.results['fragments'], list)
        self.assertIsInstance(analyzer.results['architecture_gaps'], list)
        self.assertIsInstance(analyzer.results['migration_tasks'], list)
        self.assertIsInstance(analyzer.results['recommendations'], list)
        self.assertIsInstance(analyzer.results['analysis_timestamp'], str)

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_timestamp_format(self):
        """Test that analysis timestamp is in ISO format"""
        analyzer = DeepTreeEchoAnalyzer()
        timestamp_str = analyzer.results['analysis_timestamp']
        
        try:
            # Should be able to parse as ISO format
            parsed_time = datetime.fromisoformat(timestamp_str.replace('T', ' ').replace('Z', ''))
            self.assertIsInstance(parsed_time, datetime)
        except ValueError:
            self.fail(f"Timestamp not in valid ISO format: {timestamp_str}")

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_analyze_fragments_method_exists(self):
        """Test that analyze_fragments method exists"""
        analyzer = DeepTreeEchoAnalyzer()
        
        self.assertTrue(hasattr(analyzer, 'analyze_fragments'))
        self.assertTrue(callable(analyzer.analyze_fragments))

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    @patch('pathlib.Path.glob')
    def test_analyze_fragments_functionality(self, mock_glob):
        """Test analyze_fragments basic functionality"""
        # Create mock files
        mock_file1 = Mock()
        mock_file1.is_file.return_value = True
        mock_file1.name = "echo_test.py"
        
        mock_file2 = Mock()
        mock_file2.is_file.return_value = True
        mock_file2.name = "test_echo.py"  # Should be filtered out
        
        mock_glob.return_value = [mock_file1, mock_file2]
        
        # Mock file reading
        with patch('builtins.open', mock_open(read_data="class EchoTest:\n    def test_method(self):\n        pass")):
            analyzer = DeepTreeEchoAnalyzer()
            
            try:
                fragments = analyzer.analyze_fragments()
                self.assertIsInstance(fragments, list)
                
            except Exception as e:
                # Method exists and was called, implementation may be incomplete
                if "not implemented" in str(e).lower():
                    self.skipTest("analyze_fragments method needs implementation")
                else:
                    # Method was called successfully
                    pass

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_analyzer_methods_exist(self):
        """Test that expected methods exist"""
        analyzer = DeepTreeEchoAnalyzer()
        
        expected_methods = ['analyze_fragments']
        
        for method_name in expected_methods:
            self.assertTrue(hasattr(analyzer, method_name),
                          f"Missing expected method: {method_name}")
            self.assertTrue(callable(getattr(analyzer, method_name)),
                          f"Method is not callable: {method_name}")

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_file_pattern_recognition(self):
        """Test that analyzer recognizes echo-related patterns"""
        analyzer = DeepTreeEchoAnalyzer()
        
        # Test with temporary directory structure
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            # Create test files
            echo_file = temp_path / "echo_component.py"
            echo_file.write_text("class EchoComponent:\n    pass")
            
            deep_tree_file = temp_path / "deep_tree_echo_test.py"
            deep_tree_file.write_text("def deep_tree_function():\n    pass")
            
            analyzer = DeepTreeEchoAnalyzer(temp_dir)
            
            try:
                fragments = analyzer.analyze_fragments()
                # Should find files, even if analysis is incomplete
                
            except Exception as e:
                # File discovery should work even if analysis fails
                if "glob" in str(e) or "not implemented" in str(e).lower():
                    pass
                else:
                    # Unexpected error
                    raise

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_path_handling(self):
        """Test path handling in analyzer"""
        # Test with string path
        analyzer1 = DeepTreeEchoAnalyzer("/test/path")
        self.assertEqual(analyzer1.repo_path, Path("/test/path"))
        
        # Test with Path object
        test_path = Path("/another/path")
        analyzer2 = DeepTreeEchoAnalyzer(test_path)
        self.assertEqual(analyzer2.repo_path, test_path)

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_results_initialization(self):
        """Test that results are properly initialized"""
        analyzer = DeepTreeEchoAnalyzer()
        
        # All lists should start empty
        self.assertEqual(len(analyzer.results['fragments']), 0)
        self.assertEqual(len(analyzer.results['architecture_gaps']), 0)
        self.assertEqual(len(analyzer.results['migration_tasks']), 0)
        self.assertEqual(len(analyzer.results['recommendations']), 0)
        
        # Timestamp should be recent
        timestamp_str = analyzer.results['analysis_timestamp']
        timestamp = datetime.fromisoformat(timestamp_str.replace('T', ' ').replace('Z', ''))
        now = datetime.now()
        
        # Should be within last minute
        time_diff = abs((now - timestamp).total_seconds())
        self.assertLess(time_diff, 60, "Timestamp should be recent")

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available") 
    def test_empty_directory_handling(self):
        """Test analyzer behavior with empty directory"""
        with tempfile.TemporaryDirectory() as temp_dir:
            analyzer = DeepTreeEchoAnalyzer(temp_dir)
            
            try:
                fragments = analyzer.analyze_fragments()
                # Should return empty list for empty directory
                self.assertIsInstance(fragments, list)
                
            except Exception as e:
                # Should handle empty directories gracefully
                if "not implemented" in str(e).lower():
                    self.skipTest("Method implementation incomplete")
                else:
                    # Method handles empty directories
                    pass

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_unified_architecture_methods_exist(self):
        """Test that unified architecture methods exist"""
        analyzer = DeepTreeEchoAnalyzer()
        
        # Check that unified interface methods exist
        unified_methods = ['initialize', 'process', 'echo']
        
        for method_name in unified_methods:
            self.assertTrue(hasattr(analyzer, method_name),
                          f"Missing unified interface method: {method_name}")
            self.assertTrue(callable(getattr(analyzer, method_name)),
                          f"Unified interface method is not callable: {method_name}")

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_unified_architecture_initialization(self):
        """Test unified architecture initialization"""
        try:
            from echo_component_base import EchoConfig
            
            config = EchoConfig(component_name='TestAnalyzer', version='1.0.0')
            analyzer = DeepTreeEchoAnalyzer('.', config)
            
            # Test initialization
            result = analyzer.initialize()
            
            # Should return a result object or boolean
            self.assertTrue(
                hasattr(result, 'success') or isinstance(result, bool),
                "Initialize should return EchoResponse or boolean"
            )
            
            if hasattr(result, 'success'):
                self.assertTrue(result.success, "Initialization should succeed")
                
        except ImportError:
            self.skipTest("echo_component_base not available for unified testing")

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_backward_compatibility(self):
        """Test that the analyzer works with legacy interface"""
        # Test legacy constructor (no config parameter)
        analyzer = DeepTreeEchoAnalyzer(".")
        
        # Should have the same basic structure
        self.assertEqual(analyzer.repo_path, Path("."))
        self.assertIsInstance(analyzer.results, dict)
        
        # Should still have the original methods
        self.assertTrue(hasattr(analyzer, 'analyze_fragments'))
        self.assertTrue(hasattr(analyzer, 'run_full_analysis'))

    @unittest.skipIf(not ANALYZER_AVAILABLE, "analyzer not available")
    def test_unified_architecture_inheritance(self):
        """Test that analyzer properly inherits from ProcessingEchoComponent"""
        try:
            from echo_component_base import ProcessingEchoComponent
            
            # Check inheritance
            self.assertTrue(
                issubclass(DeepTreeEchoAnalyzer, ProcessingEchoComponent) or
                ProcessingEchoComponent == object,  # Fallback case
                "DeepTreeEchoAnalyzer should inherit from ProcessingEchoComponent"
            )
            
        except ImportError:
            self.skipTest("echo_component_base not available for inheritance testing")


def main():
    """Run the test suite"""
    unittest.main(verbosity=2)


if __name__ == '__main__':
    main()